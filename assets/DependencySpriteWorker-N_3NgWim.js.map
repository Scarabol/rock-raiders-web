{"version":3,"file":"DependencySpriteWorker-N_3NgWim.js","sources":["../src/worker/TypedWorker.ts","../src/worker/AbstractWorkerSystem.ts","../src/game/model/EntityType.ts","../src/core/Sprite.ts","../src/core/ImageHelper.ts","../src/core/BitmapFont.ts","../src/worker/DependencySpriteWorker.ts"],"sourcesContent":["export interface WorkerRequestMessage<T> {\n    workerRequestHash: string\n    request: T\n}\n\nexport interface WorkerResponseMessage<T> {\n    workerRequestHash: string\n    response: T\n}\n\nexport interface TypedWorker<M> {\n    sendMessage(message: M, transfer?: (Transferable | OffscreenCanvas)[]): void\n\n    terminate(): void\n}\n\nexport class TypedWorkerFrontend<M, R> implements TypedWorker<M> {\n    constructor(readonly worker: Worker, onResponseFromWorker: (response: R) => void) {\n        worker.onmessage = (event) => {\n            onResponseFromWorker(event?.data)\n        }\n        worker.onerror = (event) => {\n            console.error(`Unexpected error event in worker`, event)\n        }\n    }\n\n    sendMessage(message: M, transfer?: (Transferable | OffscreenCanvas)[]) {\n        this.worker.postMessage(message, transfer)\n    }\n\n    terminate() {\n        this.worker.terminate()\n    }\n}\n\nexport interface TypedWorkerBackend<M, R> {\n    onMessageFromFrontend: (message: M) => void\n\n    sendResponse(response: R, transfer?: Transferable[]): void\n}\n\nexport class TypedWorkerThreaded<M, R> implements TypedWorkerBackend<M, R> {\n    onMessageFromFrontend: (message: M) => void = () => {\n        throw new Error('Not implemented')\n    }\n\n    constructor(readonly worker: Worker) {\n        worker.addEventListener('message', (event) => this.onMessageFromFrontend(event?.data))\n    }\n\n    sendResponse(response: R, transfer?: Transferable[]) {\n        this.worker.postMessage(response, transfer)\n    }\n}\n\nexport class TypedWorkerFallback<M, R> implements TypedWorker<M>, TypedWorkerBackend<M, R> {\n    onMessageFromFrontend: (message: M) => void = () => {\n        throw new Error('Not implemented')\n    }\n\n    constructor(readonly onResponseFromWorker: (response: R) => void) {\n    }\n\n    sendMessage(message: M, _transfer?: (Transferable | OffscreenCanvas)[]) {\n        this.onMessageFromFrontend(message)\n    }\n\n    sendResponse(response: R) {\n        this.onResponseFromWorker(response)\n    }\n\n    terminate() {\n    }\n}\n","import { TypedWorkerBackend, WorkerRequestMessage, WorkerResponseMessage } from './TypedWorker'\n\nexport abstract class AbstractWorkerSystem<M, R> {\n    constructor(readonly worker: TypedWorkerBackend<WorkerRequestMessage<M>, WorkerResponseMessage<R>>) {\n        worker.onMessageFromFrontend = (msg) => {\n            try {\n                if (msg.request) {\n                    this.onMessageFromFrontend(msg.workerRequestHash, msg.request)\n                } else {\n                    console.warn('Worker received message without request from frontend')\n                }\n            } catch (e) {\n                console.error(e)\n            }\n        }\n    }\n\n    abstract onMessageFromFrontend(workerRequestHash: string, request: M): void\n\n    sendResponse(workerRequestHash: string, response: R, transfer?: Transferable[]) {\n        this.worker.sendResponse({workerRequestHash: workerRequestHash, response: response}, transfer)\n    }\n}\n","export const enum EntityType {\n    NONE = '',\n    // RAIDER\n    PILOT = 'Pilot', // start with 1 otherwise entity type may fail truthiness test\n\n    // BUILDING\n    TOOLSTATION = 'Toolstation',\n    TELEPORT_PAD = 'TeleportPad',\n    DOCKS = 'Docks',\n    POWER_STATION = 'PowerStation',\n    BARRACKS = 'Barracks',\n    UPGRADE = 'Upgrade',\n    GEODOME = 'Geo-Dome',\n    ORE_REFINERY = 'OreRefinery',\n    GUNSTATION = 'Gunstation',\n    TELEPORT_BIG = 'TeleportBIG',\n\n    POWER_PATH = 'Path',\n\n    // MONSTER\n    BAT = 'Bat',\n    SMALL_SPIDER = 'SmallSpider',\n    SLUG = 'Slug',\n    ROCK_MONSTER = 'RockMonster',\n    ICE_MONSTER = 'IceMonster',\n    LAVA_MONSTER = 'LavaMonster',\n\n    // MATERIAL\n    DYNAMITE = 'Dynamite',\n    ELECTRIC_FENCE = 'ElectricFence',\n    CRYSTAL = 'PowerCrystal',\n    ORE = 'Ore',\n    BRICK = 'ProcessedOre',\n    BARRIER = 'Barrier',\n    DEPLETED_CRYSTAL = 'DepletedCrystal',\n\n    // VEHICLE\n    HOVERBOARD = 'Hoverboard',\n    SMALL_DIGGER = 'SmallDigger',\n    SMALL_TRUCK = 'SmallTruck',\n    SMALL_CAT = 'SmallCat',\n    SMALL_MLP = 'SmallMlp',\n    SMALL_HELI = 'SmallHeli',\n    BULLDOZER = 'Bulldozer',\n    WALKER_DIGGER = 'WalkerDigger',\n    LARGE_MLP = 'LargeMlp',\n    LARGE_DIGGER = 'LargeDigger',\n    LARGE_CAT = 'LargeCat',\n    LARGE_HELI = 'LargeHeli',\n\n    // OTHERS\n    TV_CAMERA = 'TvCamera',\n    LASER_SHOT = 'LaserShot',\n    FREEZER_SHOT = 'FreezerShot',\n    PUSHER_SHOT = 'PusherShot',\n    BIRD_SCARER = 'BirdScarer',\n    BOULDER = 'Boulder',\n    BOULDER_ICE = 'BoulderIce',\n}\n\nexport type MaterialEntityType = EntityType.ORE | EntityType.CRYSTAL | EntityType.BRICK | EntityType.BARRIER | EntityType.DYNAMITE | EntityType.ELECTRIC_FENCE | EntityType.DEPLETED_CRYSTAL\n\nexport type VehicleEntityType = EntityType.HOVERBOARD | EntityType.SMALL_DIGGER | EntityType.SMALL_TRUCK | EntityType.SMALL_CAT | EntityType.SMALL_MLP | EntityType.SMALL_HELI | EntityType.BULLDOZER | EntityType.WALKER_DIGGER | EntityType.LARGE_MLP | EntityType.LARGE_DIGGER | EntityType.LARGE_CAT | EntityType.LARGE_HELI\n\nexport type MonsterEntityType = EntityType.NONE | EntityType.SMALL_SPIDER | EntityType.BAT | EntityType.SLUG | EntityType.ICE_MONSTER | EntityType.LAVA_MONSTER | EntityType.ROCK_MONSTER\n\nexport function getEntityTypeByName(type: string): EntityType {\n    if ('TVCamera'.equalsIgnoreCase(type)) {\n        return EntityType.TV_CAMERA\n    } else if ('Pilot'.equalsIgnoreCase(type)) {\n        return EntityType.PILOT\n    } else if ('Toolstation'.equalsIgnoreCase(type)) {\n        return EntityType.TOOLSTATION\n    } else if ('TeleportPad'.equalsIgnoreCase(type)) {\n        return EntityType.TELEPORT_PAD\n    } else if ('Docks'.equalsIgnoreCase(type)) {\n        return EntityType.DOCKS\n    } else if ('PowerStation'.equalsIgnoreCase(type)) {\n        return EntityType.POWER_STATION\n    } else if ('Barracks'.equalsIgnoreCase(type)) {\n        return EntityType.BARRACKS\n    } else if ('Upgrade'.equalsIgnoreCase(type)) {\n        return EntityType.UPGRADE\n    } else if ('GEO-Dome'.equalsIgnoreCase(type) || 'geodome'.equalsIgnoreCase(type)) {\n        return EntityType.GEODOME\n    } else if ('OreRefinery'.equalsIgnoreCase(type)) {\n        return EntityType.ORE_REFINERY\n    } else if ('GunStation'.equalsIgnoreCase(type)) {\n        return EntityType.GUNSTATION\n    } else if ('TeleportBIG'.equalsIgnoreCase(type)) {\n        return EntityType.TELEPORT_BIG\n    } else if ('Path'.equalsIgnoreCase(type)) {\n        return EntityType.POWER_PATH\n    } else if ('Bat'.equalsIgnoreCase(type)) {\n        return EntityType.BAT\n    } else if ('SmallSpider'.equalsIgnoreCase(type)) {\n        return EntityType.SMALL_SPIDER\n    } else if ('RockMonster'.equalsIgnoreCase(type)) {\n        return EntityType.ROCK_MONSTER\n    } else if ('IceMonster'.equalsIgnoreCase(type)) {\n        return EntityType.ICE_MONSTER\n    } else if ('LavaMonster'.equalsIgnoreCase(type)) {\n        return EntityType.LAVA_MONSTER\n    } else if ('Dynamite'.equalsIgnoreCase(type)) {\n        return EntityType.DYNAMITE\n    } else if ('ElectricFence'.equalsIgnoreCase(type)) {\n        return EntityType.ELECTRIC_FENCE\n    } else if ('PowerCrystal'.equalsIgnoreCase(type)) {\n        return EntityType.CRYSTAL\n    } else if ('Ore'.equalsIgnoreCase(type)) {\n        return EntityType.ORE\n    } else if ('Brick'.equalsIgnoreCase(type)) {\n        return EntityType.BRICK\n    } else if ('Barrier'.equalsIgnoreCase(type)) {\n        return EntityType.BARRIER\n    } else if ('DepletedCrystal'.equalsIgnoreCase(type)) {\n        return EntityType.DEPLETED_CRYSTAL\n    } else if ('Hoverboard'.equalsIgnoreCase(type)) {\n        return EntityType.HOVERBOARD\n    } else if ('SmallDigger'.equalsIgnoreCase(type)) {\n        return EntityType.SMALL_DIGGER\n    } else if ('SmallTruck'.equalsIgnoreCase(type)) {\n        return EntityType.SMALL_TRUCK\n    } else if ('SmallCat'.equalsIgnoreCase(type)) {\n        return EntityType.SMALL_CAT\n    } else if ('SmallMLP'.equalsIgnoreCase(type)) {\n        return EntityType.SMALL_MLP\n    } else if ('SmallHeli'.equalsIgnoreCase(type)) {\n        return EntityType.SMALL_HELI\n    } else if ('Bulldozer'.equalsIgnoreCase(type)) {\n        return EntityType.BULLDOZER\n    } else if ('WalkerDigger'.equalsIgnoreCase(type)) {\n        return EntityType.WALKER_DIGGER\n    } else if ('LargeMLP'.equalsIgnoreCase(type)) {\n        return EntityType.LARGE_MLP\n    } else if ('LargeDigger'.equalsIgnoreCase(type)) {\n        return EntityType.LARGE_DIGGER\n    } else if ('LargeCat'.equalsIgnoreCase(type)) {\n        return EntityType.LARGE_CAT\n    } else if ('LargeHeli'.equalsIgnoreCase(type)) {\n        return EntityType.LARGE_HELI\n    } else {\n        return EntityType.NONE\n    }\n}\n\nexport function getMonsterEntityTypeByName(type: string): MonsterEntityType | EntityType.NONE {\n    if ('Bat'.equalsIgnoreCase(type)) {\n        return EntityType.BAT\n    } else if ('SmallSpider'.equalsIgnoreCase(type)) {\n        return EntityType.SMALL_SPIDER\n    } else if ('RockMonster'.equalsIgnoreCase(type)) {\n        return EntityType.ROCK_MONSTER\n    } else if ('IceMonster'.equalsIgnoreCase(type)) {\n        return EntityType.ICE_MONSTER\n    } else if ('LavaMonster'.equalsIgnoreCase(type)) {\n        return EntityType.LAVA_MONSTER\n    } else {\n        console.warn(`Could not find monster entity type for given '${type}'`)\n        return EntityType.NONE\n    }\n}\n","export type SpriteImage = HTMLCanvasElement | OffscreenCanvas\n\nexport type SpriteContext = CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D\n\nexport function getSpriteContext(canvas: SpriteImage | undefined, contextAttributes?: CanvasRenderingContext2DSettings): SpriteContext {\n    if (!canvas) throw new Error('No canvas given')\n    const context = canvas.getContext('2d', contextAttributes)\n    if (!context) throw new Error('Could not get context')\n    return context as SpriteContext\n}\n","import { getSpriteContext, SpriteContext, SpriteImage } from './Sprite'\n\nexport function createCanvas(width: number, height: number): HTMLCanvasElement {\n    const canvas = document.createElement('canvas')\n    canvas.width = width\n    canvas.height = height\n    return canvas\n}\n\nexport function createContext(width: number, height: number): SpriteContext {\n    if (width < 1 || height < 1) {\n        console.error(`Can't create context with size ${width} x ${height}`)\n        return createDummyContext(64, 64)\n    }\n    let canvas: SpriteImage\n    if (typeof document !== 'undefined') {\n        canvas = createCanvas(width, height)\n    } else {\n        canvas = new OffscreenCanvas(width, height)\n    }\n    return getSpriteContext(canvas)\n}\n\n/**\n * This method is intended to increase stability by providing an (ugly) placeholder image in case the right one is missing\n * @param width expected width of the original image\n * @param height expected height of the original image\n */\nexport function createDummyContext(width: number, height: number): SpriteContext {\n    const result = createContext(width, height)\n    for (let y = 0; y < height; y += 16) {\n        for (let x = 0; x < width; x += 16) {\n            if (x / 16 % 2 === y / 16 % 2) {\n                result.fillStyle = 'rgb(0,255,255)'\n            } else {\n                result.fillStyle = 'rgb(255,0,255)'\n            }\n            result.fillRect(x, y, 16, 16)\n        }\n    }\n    return result\n}\n\nexport function createDummyImgData(width: number, height: number): ImageData {\n    const result = new ImageData(width, height)\n    for (let y = 0; y < height; y += 16) {\n        for (let x = 0; x < width; x += 16) {\n            const e = x / 16 % 2 === y / 16 % 2\n            for (let px = x; px < x + 16; px++) {\n                for (let py = y; py < y + 16; py++) {\n                    setPixel(result, px, py, e ? 0 : 255, e ? 255 : 0, 255)\n                }\n            }\n        }\n    }\n    return result\n}\n\nexport function setPixel(imgData: ImageData, x: number, y: number, r: number, g: number, b: number, a: number = 255): void {\n    const n = (y * imgData.width + x) * 4\n    imgData.data[n] = r\n    imgData.data[n + 1] = g\n    imgData.data[n + 2] = b\n    imgData.data[n + 3] = a\n}\n\nexport function getPixel(imgData: ImageData, x: number, y: number): { r: number; g: number; b: number; a: number } {\n    const n = (y * imgData.width + x) * 4\n    return {r: imgData.data[n], g: imgData.data[n + 1], b: imgData.data[n + 2], a: imgData.data[n + 3]}\n}\n\nexport function imgDataToCanvas(imgData: ImageData): SpriteImage {\n    const context = createContext(imgData.width, imgData.height)\n    context.putImageData(imgData, 0, 0)\n    return context.canvas\n}\n","import { createContext, createDummyImgData, getPixel, setPixel } from './ImageHelper'\nimport { SpriteImage } from './Sprite'\n\nexport class BitmapFontData {\n    readonly charCodeMap: Map<number, ImageData> = new Map()\n    readonly alphaColor: { r: number, g: number, b: number }\n    readonly spaceWidth: number\n\n    constructor(fontImageData: ImageData, readonly charHeight: number) {\n        if (!fontImageData) throw new Error('No font image data given')\n        if (charHeight < 1) throw new Error(`Invalid char height (${charHeight}) given`)\n        const cols = 10, rows = Math.floor(fontImageData.height / charHeight)\n        // XXX find better way to detect char dimensions\n        const maxCharWidth = fontImageData.width / cols\n        this.alphaColor = getPixel(fontImageData, 0, 0)\n\n        function isLimiterColor(imgData: ImageData, index: number): boolean {\n            // Last pixel in the first row of the first char defines the end of char limiter color (e.g. 255,39,0),\n            // because tooltipfont.bmp uses alphaColor at the end of the file\n            return imgData.data[index] === fontImageData.data[(maxCharWidth - 1) * 4]\n                && imgData.data[index + 1] === fontImageData.data[(maxCharWidth - 1) * 4 + 1]\n                && imgData.data[index + 2] === fontImageData.data[(maxCharWidth - 1) * 4 + 2]\n        }\n\n        function getActualCharacterWidth(imgData: ImageData) {\n            for (let y = 0; y < imgData.height; y++) {\n                if (isLimiterColor(imgData, y * 4 * imgData.width)) continue // find non-empty row first\n                for (let x = 0; x < maxCharWidth; x++) {\n                    if (isLimiterColor(imgData, y * 4 * imgData.width + x * 4)) return x\n                }\n                return maxCharWidth\n            }\n            return imgData.width\n        }\n\n        for (let i = 0; i < cols * rows; i++) {\n            let imgData = this.extractData(fontImageData, (i % 10) * maxCharWidth, Math.floor(i / 10) * this.charHeight, maxCharWidth)\n            const actualWidth = getActualCharacterWidth(imgData)\n            if (actualWidth > 0) {\n                imgData = this.extractData(imgData, 0, 0, actualWidth)\n            } else {\n                console.warn(`Could not determine actual character width for '${i}'. Adding dummy sprite to letter map`)\n                imgData = createDummyImgData(maxCharWidth, this.charHeight)\n            }\n            this.charCodeMap.set(i + 32, imgData) // Config files use custom encoding with offset (32) to bitmap fonts index\n        }\n\n        this.spaceWidth = this.charCodeMap.get(' '.charCodeAt(0))?.width || 10\n    }\n\n    extractData(imgData: ImageData, startX: number, startY: number, width: number): ImageData {\n        const result = new ImageData(width, this.charHeight)\n        for (let x = 0; x < width; x++) {\n            for (let y = 0; y < this.charHeight; y++) {\n                const p = getPixel(imgData, startX + x, startY + y)\n                if (p.r === this.alphaColor.r && p.g === this.alphaColor.g && p.b === this.alphaColor.b) p.a = 0 // apply alpha channel\n                setPixel(result, x, y, p.r, p.g, p.b, p.a)\n            }\n        }\n        return result\n    }\n}\n\nexport class BitmapFont {\n    constructor(readonly data: BitmapFontData) {\n    }\n\n    createTextImageData(text: string, maxWidth?: number, autoCenter: boolean = true): ImageData | undefined {\n        if (!text) return undefined\n        text = text.replace(/_/g, ' ') // TODO All underscores should be replaced in config parsing\n        const rows = this.determineRows(text, maxWidth)\n        const width = Math.max(1, ...(rows.map(r => r.width)))\n        const result = new ImageData(width, this.data.charHeight * (rows.length || 1))\n        rows.forEach((row, index) => {\n            const rowX = autoCenter ? Math.round((width - row.width) / 2) : 0\n            const rowY = index * this.data.charHeight\n            let letterX = 0\n            for (let c = 0; c < row.text.length; c++) {\n                const letterImgData = this.data.charCodeMap.get(row.text.charCodeAt(c))\n                if (letterImgData) {\n                    for (let x = letterX; x < letterX + letterImgData.width; x++) {\n                        for (let y = 0; y < letterImgData.height; y++) {\n                            const p = getPixel(letterImgData, x - letterX, y)\n                            setPixel(result, rowX + x, rowY + y, p.r, p.g, p.b, p.a)\n                        }\n                    }\n                    letterX += letterImgData.width\n                } // missing letter issue already reported above\n            }\n        })\n        return result\n    }\n\n    createTextImage(text: string, maxWidth?: number, autoCenter: boolean = true): SpriteImage | undefined {\n        if (!text) return undefined\n        const result = this.createTextImageData(text, maxWidth, autoCenter)\n        if (!result) return undefined\n        const img = createContext(result.width, result.height)\n        img.putImageData(result, 0, 0)\n        return img.canvas\n    }\n\n    private determineRows(text: string, maxWidth?: number): { text: string, width: number }[] {\n        const rows: { text: string, width: number }[] = []\n        let rowText = ''\n        let rowWidth = 0\n        text.replaceAll('\\t', '    ').split(' ').forEach((word) => {\n            let wordWidth = 0\n            for (let c = 0; c < word.length; c++) {\n                const charCode = word.charCodeAt(c)\n                const letterImg = this.data.charCodeMap.get(charCode)\n                if (letterImg) {\n                    wordWidth += letterImg.width\n                } else {\n                    const letter = word.charAt(c)\n                    if (charCode !== 13) { // ignore carriage return\n                        console.error(`Ignoring letter '${letter}' (${charCode}) of word \"${text}\" not found in charset of size ${this.data.charCodeMap.size}!`)\n                    }\n                }\n            }\n            if (rowWidth > 0) {\n                if (!maxWidth || rowWidth + this.data.spaceWidth + wordWidth < maxWidth) {\n                    rowText += ` ${word}`\n                    rowWidth += this.data.spaceWidth + wordWidth\n                } else {\n                    rows.push({text: rowText, width: rowWidth})\n                    rowText = word\n                    rowWidth = wordWidth\n                }\n            } else {\n                rowText += word\n                rowWidth += wordWidth\n            }\n        })\n        if (rowWidth > 0) rows.push({text: rowText, width: rowWidth})\n        return rows\n    }\n}\n","import { TypedWorkerThreaded } from './TypedWorker'\nimport { AbstractWorkerSystem } from './AbstractWorkerSystem'\nimport { SpriteImage } from '../core/Sprite'\nimport { EntityType } from '../game/model/EntityType'\nimport { createContext, imgDataToCanvas } from '../core/ImageHelper'\nimport { EntityDependencyChecked } from '../cfg/GameConfig'\nimport { BitmapFont, BitmapFontData } from '../core/BitmapFont'\n\nexport const enum DependencySpriteWorkerRequestType {\n    SETUP = 1, // start with 1 for truthiness safety\n    CREATE_SPRITE,\n}\n\nexport interface DependencySpriteWorkerSetupRequest {\n    type: DependencySpriteWorkerRequestType.SETUP\n    upgradeNames: string[]\n    tooltipFontData: BitmapFontData\n    plusSignImgData: ImageData\n    equalSignImgData: ImageData\n    interfaceImageData: Map<string, [ImageData, ImageData]>\n    interfaceBuildImageData: Map<string, [ImageData, ImageData]>\n}\n\nexport interface DependencySpriteWorkerCreateSpriteRequest {\n    type: DependencySpriteWorkerRequestType.CREATE_SPRITE\n    dependencies: EntityDependencyChecked[]\n}\n\nexport type DependencySpriteWorkerRequest = DependencySpriteWorkerSetupRequest | DependencySpriteWorkerCreateSpriteRequest\n\nexport interface DependencySpriteWorkerResponse {\n    dependencyImage?: ImageData\n}\n\nexport class DependencySpriteSystem extends AbstractWorkerSystem<DependencySpriteWorkerRequest, DependencySpriteWorkerResponse> {\n    readonly interfaceImages: Map<string, [SpriteImage, SpriteImage]> = new Map()\n    readonly interfaceBuildImages: Map<string, [SpriteImage, SpriteImage]> = new Map()\n    upgradeNames?: string[]\n    tooltipFont: BitmapFont | undefined\n    plusSignImg: SpriteImage | undefined\n    equalsSignImg: SpriteImage | undefined\n\n    onMessageFromFrontend(workerRequestHash: string, request: DependencySpriteWorkerRequest): void {\n        switch (request.type) {\n            case DependencySpriteWorkerRequestType.SETUP:\n                this.upgradeNames = request.upgradeNames\n                this.tooltipFont = new BitmapFont(request.tooltipFontData)\n                this.plusSignImg = imgDataToCanvas(request.plusSignImgData)\n                this.equalsSignImg = imgDataToCanvas(request.equalSignImgData)\n                request.interfaceImageData.forEach((imgData, key) => this.interfaceImages\n                    .set(key.toLowerCase(), [imgDataToCanvas(imgData[0]), imgDataToCanvas(imgData[1])]))\n                request.interfaceBuildImageData.forEach((imgData, key) => this.interfaceBuildImages\n                    .set(key.toLowerCase(), [imgDataToCanvas(imgData[0]), imgDataToCanvas(imgData[1])]))\n                this.sendResponse(workerRequestHash, {})\n                break\n            case DependencySpriteWorkerRequestType.CREATE_SPRITE:\n                const upgradeNames = this.upgradeNames\n                const tooltipFont = this.tooltipFont\n                const plusSignImg = this.plusSignImg\n                const equalsSignImg = this.equalsSignImg\n                if (!upgradeNames || !tooltipFont || !plusSignImg || !equalsSignImg) {\n                    console.error('Dependency sprite worker not yet setup', upgradeNames, tooltipFont, plusSignImg, equalsSignImg)\n                    this.sendResponse(workerRequestHash, {})\n                    return\n                }\n                let totalWidth = 0\n                let totalHeight = 0\n                const deps = request.dependencies.map((dep) => {\n                    let depImages: [SpriteImage, SpriteImage] | undefined\n                    if (dep.entityType === EntityType.PILOT) {\n                        depImages = this.interfaceImages.get('Interface_MenuItem_TeleportMan'.toLowerCase()) // TODO Improve config parsing and use specific key here\n                    } else {\n                        depImages = this.interfaceBuildImages.get(dep.itemKey.toLowerCase()) // TODO Improve config parsing and use specific key here\n                    }\n                    if (!Array.isArray(depImages) || depImages.length !== 2) throw new Error(`Unexpected dependency images array (${depImages})`)\n                    const depImg = dep.isOk ? depImages[0] : depImages[1]\n                    totalWidth += depImg.width\n                    totalHeight = Math.max(totalHeight, depImg.height)\n                    return {img: depImg, level: dep.minLevel}\n                })\n                totalWidth += plusSignImg.width * (deps.length - 1)\n                totalWidth += equalsSignImg.width * 2\n                const dependencySprite = createContext(totalWidth, totalHeight)\n                let posX = 0\n                deps.forEach((s, index) => {\n                    dependencySprite.drawImage(s.img, posX, (totalHeight - s.img.height) / 2)\n                    if (s.level) {\n                        const upgradeName = upgradeNames[s.level - 1]\n                        if (upgradeName) {\n                            const minLevelImg = tooltipFont.createTextImage(upgradeName)\n                            if (minLevelImg) dependencySprite.drawImage(minLevelImg, posX + 3, (totalHeight - s.img.height) / 2 + 3)\n                        }\n                    }\n                    posX += s.img.width\n                    const signImg = index === deps.length - 1 ? equalsSignImg : plusSignImg\n                    dependencySprite.drawImage(signImg, posX, (totalHeight - signImg.height) / 2)\n                    posX += signImg.width\n                })\n                this.sendResponse(workerRequestHash, {dependencyImage: dependencySprite.getImageData(0, 0, dependencySprite.canvas.width, dependencySprite.canvas.height)})\n                break\n        }\n    }\n}\n\nconst worker: Worker = self as any\nnew DependencySpriteSystem(new TypedWorkerThreaded(worker))\n"],"names":["TypedWorkerThreaded","worker","event","response","transfer","AbstractWorkerSystem","msg","e","workerRequestHash","EntityType","getSpriteContext","canvas","contextAttributes","context","createCanvas","width","height","createContext","createDummyContext","result","y","x","setPixel","imgData","r","g","b","a","getPixel","n","imgDataToCanvas","BitmapFont","data","text","maxWidth","autoCenter","rows","row","index","rowX","rowY","letterX","letterImgData","p","img","rowText","rowWidth","word","wordWidth","c","charCode","letterImg","letter","DependencySpriteSystem","request","key","upgradeNames","tooltipFont","plusSignImg","equalsSignImg","totalWidth","totalHeight","deps","dep","depImages","depImg","dependencySprite","posX","s","upgradeName","minLevelImg","signImg"],"mappings":"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"}