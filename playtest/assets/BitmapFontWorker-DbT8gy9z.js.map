{"version":3,"file":"BitmapFontWorker-DbT8gy9z.js","sources":["../src/worker/AbstractWorkerSystem.ts","../src/core/Sprite.ts","../src/core/ImageHelper.ts","../src/core/BitmapFont.ts","../src/worker/TypedWorker.ts","../src/worker/BitmapFontWorker.ts"],"sourcesContent":["import { TypedWorkerBackend, WorkerRequestMessage, WorkerResponseMessage } from './TypedWorker'\n\nexport abstract class AbstractWorkerSystem<M, R> {\n    constructor(readonly worker: TypedWorkerBackend<WorkerRequestMessage<M>, WorkerResponseMessage<R>>) {\n        worker.onMessageFromFrontend = (msg) => {\n            try {\n                if (msg.request) {\n                    this.onMessageFromFrontend(msg.workerRequestHash, msg.request)\n                } else {\n                    console.warn('Worker received message without request from frontend')\n                }\n            } catch (e) {\n                console.error(e)\n            }\n        }\n    }\n\n    abstract onMessageFromFrontend(workerRequestHash: string, request: M): void\n\n    sendResponse(workerRequestHash: string, response: R, transfer?: Transferable[]) {\n        this.worker.sendResponse({workerRequestHash: workerRequestHash, response: response}, transfer)\n    }\n}\n","export type SpriteImage = HTMLCanvasElement | OffscreenCanvas\n\nexport type SpriteContext = CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D\n\nexport function getSpriteContext(canvas: SpriteImage | undefined, contextAttributes?: CanvasRenderingContext2DSettings): SpriteContext {\n    if (!canvas) throw new Error('No canvas given')\n    const context = canvas.getContext('2d', contextAttributes)\n    if (!context) throw new Error('Could not get context')\n    return context as SpriteContext\n}\n","import { getSpriteContext, SpriteContext, SpriteImage } from './Sprite'\n\nexport function createCanvas(width: number, height: number): HTMLCanvasElement {\n    const canvas = document.createElement('canvas')\n    canvas.width = width\n    canvas.height = height\n    return canvas\n}\n\nexport function createContext(width: number, height: number): SpriteContext {\n    if (width < 1 || height < 1) {\n        console.error(`Can't create context with size ${width} x ${height}`)\n        return createDummyContext(64, 64)\n    }\n    let canvas: SpriteImage\n    if (typeof document !== 'undefined') {\n        canvas = createCanvas(width, height)\n    } else {\n        canvas = new OffscreenCanvas(width, height)\n    }\n    return getSpriteContext(canvas)\n}\n\n/**\n * This method is intended to increase stability by providing an (ugly) placeholder image in case the right one is missing\n * @param width expected width of the original image\n * @param height expected height of the original image\n */\nexport function createDummyContext(width: number, height: number): SpriteContext {\n    const result = createContext(width, height)\n    for (let y = 0; y < height; y += 16) {\n        for (let x = 0; x < width; x += 16) {\n            if (x / 16 % 2 === y / 16 % 2) {\n                result.fillStyle = 'rgb(0,255,255)'\n            } else {\n                result.fillStyle = 'rgb(255,0,255)'\n            }\n            result.fillRect(x, y, 16, 16)\n        }\n    }\n    return result\n}\n\nexport function createDummyImgData(width: number, height: number): ImageData {\n    const result = new ImageData(width, height)\n    for (let y = 0; y < height; y += 16) {\n        for (let x = 0; x < width; x += 16) {\n            const e = x / 16 % 2 === y / 16 % 2\n            for (let px = x; px < x + 16; px++) {\n                for (let py = y; py < y + 16; py++) {\n                    setPixel(result, px, py, e ? 0 : 255, e ? 255 : 0, 255)\n                }\n            }\n        }\n    }\n    return result\n}\n\nexport function setPixel(imgData: ImageData, x: number, y: number, r: number, g: number, b: number, a: number = 255): void {\n    const n = (y * imgData.width + x) * 4\n    imgData.data[n] = r\n    imgData.data[n + 1] = g\n    imgData.data[n + 2] = b\n    imgData.data[n + 3] = a\n}\n\nexport function getPixel(imgData: ImageData, x: number, y: number): { r: number; g: number; b: number; a: number } {\n    const n = (y * imgData.width + x) * 4\n    return {r: imgData.data[n], g: imgData.data[n + 1], b: imgData.data[n + 2], a: imgData.data[n + 3]}\n}\n\nexport function imgDataToCanvas(imgData: ImageData): SpriteImage {\n    const context = createContext(imgData.width, imgData.height)\n    context.putImageData(imgData, 0, 0)\n    return context.canvas\n}\n","import { createContext, createDummyImgData, getPixel, setPixel } from './ImageHelper'\nimport { SpriteImage } from './Sprite'\n\nexport class BitmapFontData {\n    readonly charCodeMap: Map<number, ImageData> = new Map()\n    readonly alphaColor: { r: number, g: number, b: number }\n    readonly spaceWidth: number\n\n    constructor(fontImageData: ImageData, readonly charHeight: number) {\n        if (!fontImageData) throw new Error('No font image data given')\n        if (charHeight < 1) throw new Error(`Invalid char height (${charHeight}) given`)\n        const cols = 10, rows = Math.floor(fontImageData.height / charHeight)\n        // XXX find better way to detect char dimensions\n        const maxCharWidth = fontImageData.width / cols\n        this.alphaColor = getPixel(fontImageData, 0, 0)\n\n        function isLimiterColor(imgData: ImageData, index: number): boolean {\n            // Last pixel in the first row of the first char defines the end of char limiter color (e.g. 255,39,0),\n            // because tooltipfont.bmp uses alphaColor at the end of the file\n            return imgData.data[index] === fontImageData.data[(maxCharWidth - 1) * 4]\n                && imgData.data[index + 1] === fontImageData.data[(maxCharWidth - 1) * 4 + 1]\n                && imgData.data[index + 2] === fontImageData.data[(maxCharWidth - 1) * 4 + 2]\n        }\n\n        function getActualCharacterWidth(imgData: ImageData) {\n            for (let y = 0; y < imgData.height; y++) {\n                if (isLimiterColor(imgData, y * 4 * imgData.width)) continue // find non-empty row first\n                for (let x = 0; x < maxCharWidth; x++) {\n                    if (isLimiterColor(imgData, y * 4 * imgData.width + x * 4)) return x\n                }\n                return maxCharWidth\n            }\n            return imgData.width\n        }\n\n        for (let i = 0; i < cols * rows; i++) {\n            let imgData = this.extractData(fontImageData, (i % 10) * maxCharWidth, Math.floor(i / 10) * this.charHeight, maxCharWidth)\n            const actualWidth = getActualCharacterWidth(imgData)\n            if (actualWidth > 0) {\n                imgData = this.extractData(imgData, 0, 0, actualWidth)\n            } else {\n                console.warn(`Could not determine actual character width for '${i}'. Adding dummy sprite to letter map`)\n                imgData = createDummyImgData(maxCharWidth, this.charHeight)\n            }\n            this.charCodeMap.set(i + 32, imgData) // Config files use custom encoding with offset (32) to bitmap fonts index\n        }\n\n        this.spaceWidth = this.charCodeMap.get(' '.charCodeAt(0))?.width || 10\n    }\n\n    extractData(imgData: ImageData, startX: number, startY: number, width: number): ImageData {\n        const result = new ImageData(width, this.charHeight)\n        for (let x = 0; x < width; x++) {\n            for (let y = 0; y < this.charHeight; y++) {\n                const p = getPixel(imgData, startX + x, startY + y)\n                if (p.r === this.alphaColor.r && p.g === this.alphaColor.g && p.b === this.alphaColor.b) p.a = 0 // apply alpha channel\n                setPixel(result, x, y, p.r, p.g, p.b, p.a)\n            }\n        }\n        return result\n    }\n}\n\nexport class BitmapFont {\n    constructor(readonly data: BitmapFontData) {\n    }\n\n    createTextImageData(text: string, maxWidth?: number, autoCenter: boolean = true): ImageData | undefined {\n        if (!text) return undefined\n        text = text.replace(/_/g, ' ') // TODO All underscores should be replaced in config parsing\n        const rows = this.determineRows(text, maxWidth)\n        const width = Math.max(1, ...(rows.map(r => r.width)))\n        const result = new ImageData(width, this.data.charHeight * (rows.length || 1))\n        rows.forEach((row, index) => {\n            const rowX = autoCenter ? Math.round((width - row.width) / 2) : 0\n            const rowY = index * this.data.charHeight\n            let letterX = 0\n            for (let c = 0; c < row.text.length; c++) {\n                const letterImgData = this.data.charCodeMap.get(row.text.charCodeAt(c))\n                if (letterImgData) {\n                    for (let x = letterX; x < letterX + letterImgData.width; x++) {\n                        for (let y = 0; y < letterImgData.height; y++) {\n                            const p = getPixel(letterImgData, x - letterX, y)\n                            setPixel(result, rowX + x, rowY + y, p.r, p.g, p.b, p.a)\n                        }\n                    }\n                    letterX += letterImgData.width\n                } // missing letter issue already reported above\n            }\n        })\n        return result\n    }\n\n    createTextImage(text: string, maxWidth?: number, autoCenter: boolean = true): SpriteImage | undefined {\n        if (!text) return undefined\n        const result = this.createTextImageData(text, maxWidth, autoCenter)\n        if (!result) return undefined\n        const img = createContext(result.width, result.height)\n        img.putImageData(result, 0, 0)\n        return img.canvas\n    }\n\n    private determineRows(text: string, maxWidth?: number): { text: string, width: number }[] {\n        const rows: { text: string, width: number }[] = []\n        let rowText = ''\n        let rowWidth = 0\n        text.replaceAll('\\t', '    ').split(' ').forEach((word) => {\n            let wordWidth = 0\n            for (let c = 0; c < word.length; c++) {\n                const charCode = word.charCodeAt(c)\n                const letterImg = this.data.charCodeMap.get(charCode)\n                if (letterImg) {\n                    wordWidth += letterImg.width\n                } else {\n                    const letter = word.charAt(c)\n                    if (charCode !== 13) { // ignore carriage return\n                        console.error(`Ignoring letter '${letter}' (${charCode}) of word \"${text}\" not found in charset of size ${this.data.charCodeMap.size}!`)\n                    }\n                }\n            }\n            if (rowWidth > 0) {\n                if (!maxWidth || rowWidth + this.data.spaceWidth + wordWidth < maxWidth) {\n                    rowText += ` ${word}`\n                    rowWidth += this.data.spaceWidth + wordWidth\n                } else {\n                    rows.push({text: rowText, width: rowWidth})\n                    rowText = word\n                    rowWidth = wordWidth\n                }\n            } else {\n                rowText += word\n                rowWidth += wordWidth\n            }\n        })\n        if (rowWidth > 0) rows.push({text: rowText, width: rowWidth})\n        return rows\n    }\n}\n","export interface WorkerRequestMessage<T> {\n    workerRequestHash: string\n    request: T\n}\n\nexport interface WorkerResponseMessage<T> {\n    workerRequestHash: string\n    response: T\n}\n\nexport interface TypedWorker<M> {\n    sendMessage(message: M, transfer?: (Transferable | OffscreenCanvas)[]): void\n\n    terminate(): void\n}\n\nexport class TypedWorkerFrontend<M, R> implements TypedWorker<M> {\n    constructor(readonly worker: Worker, onResponseFromWorker: (response: R) => void) {\n        worker.onmessage = (event) => {\n            onResponseFromWorker(event?.data)\n        }\n        worker.onerror = (event) => {\n            console.error(`Unexpected error event in worker`, event)\n        }\n    }\n\n    sendMessage(message: M, transfer?: (Transferable | OffscreenCanvas)[]) {\n        this.worker.postMessage(message, transfer)\n    }\n\n    terminate() {\n        this.worker.terminate()\n    }\n}\n\nexport interface TypedWorkerBackend<M, R> {\n    onMessageFromFrontend: (message: M) => void\n\n    sendResponse(response: R, transfer?: Transferable[]): void\n}\n\nexport class TypedWorkerThreaded<M, R> implements TypedWorkerBackend<M, R> {\n    onMessageFromFrontend: (message: M) => void = () => {\n        throw new Error('Not implemented')\n    }\n\n    constructor(readonly worker: Worker) {\n        worker.addEventListener('message', (event) => this.onMessageFromFrontend(event?.data))\n    }\n\n    sendResponse(response: R, transfer?: Transferable[]) {\n        this.worker.postMessage(response, transfer)\n    }\n}\n\nexport class TypedWorkerFallback<M, R> implements TypedWorker<M>, TypedWorkerBackend<M, R> {\n    onMessageFromFrontend: (message: M) => void = () => {\n        throw new Error('Not implemented')\n    }\n\n    constructor(readonly onResponseFromWorker: (response: R) => void) {\n    }\n\n    sendMessage(message: M, _transfer?: (Transferable | OffscreenCanvas)[]) {\n        this.onMessageFromFrontend(message)\n    }\n\n    sendResponse(response: R) {\n        this.onResponseFromWorker(response)\n    }\n\n    terminate() {\n    }\n}\n","import { AbstractWorkerSystem } from './AbstractWorkerSystem'\nimport { BitmapFont, BitmapFontData } from '../core/BitmapFont'\nimport { TypedWorkerThreaded } from './TypedWorker'\n\nexport const BITMAP_FONT_WORKER_REQUEST_TYPE = {\n    addFont: 1, // start with 1 for truthiness safety\n    createTextImage: 2,\n} as const\ntype BitmapFontWorkerRequestType = typeof BITMAP_FONT_WORKER_REQUEST_TYPE[keyof typeof BITMAP_FONT_WORKER_REQUEST_TYPE]\n\nexport interface BitmapFontWorkerRequest {\n    type: BitmapFontWorkerRequestType\n    fontName: string\n    fontData?: BitmapFontData\n    text?: string\n    maxWidth?: number\n    autoCenter?: boolean\n}\n\nexport interface BitmapFontWorkerResponse {\n    textImageData?: ImageData\n}\n\nexport class BitmapFontSystem extends AbstractWorkerSystem<BitmapFontWorkerRequest, BitmapFontWorkerResponse> {\n    private readonly fontCache: Map<string, BitmapFont> = new Map()\n\n    onMessageFromFrontend(workerRequestHash: string, request: BitmapFontWorkerRequest) {\n        if (!request.fontName) {\n            console.error(`No fontname given for '${request.text}'`)\n            this.sendResponse(workerRequestHash, {textImageData: undefined})\n            return\n        }\n        switch (request.type) {\n            case BITMAP_FONT_WORKER_REQUEST_TYPE.addFont:\n                if (!request.fontData) {\n                    console.error(`No font data given for '${request.fontName}'`)\n                    this.sendResponse(workerRequestHash, {textImageData: undefined})\n                    return\n                }\n                this.fontCache.set(request.fontName.toLowerCase(), new BitmapFont(request.fontData))\n                this.sendResponse(workerRequestHash, {textImageData: undefined})\n                break\n            case BITMAP_FONT_WORKER_REQUEST_TYPE.createTextImage:\n                if (!request.text) {\n                    console.error(`No text given for '${request.fontName}'`)\n                    this.sendResponse(workerRequestHash, {textImageData: undefined})\n                    return\n                }\n                const font = this.fontCache.get(request.fontName.toLowerCase())\n                if (!font) {\n                    console.error(`Unknown font '${request.fontName}' for '${request.text}'. Possible options are: ${Array.from(this.fontCache.keys())}`)\n                    this.sendResponse(workerRequestHash, {textImageData: undefined})\n                    return\n                }\n                const textImageData = font.createTextImageData(request.text, request.maxWidth, request.autoCenter)\n                this.sendResponse(workerRequestHash, {textImageData: textImageData})\n                break\n        }\n    }\n}\n\nconst worker: Worker = self as any\nnew BitmapFontSystem(new TypedWorkerThreaded(worker))\n"],"names":["AbstractWorkerSystem","worker","msg","e","workerRequestHash","response","transfer","getSpriteContext","canvas","contextAttributes","context","createCanvas","width","height","createContext","createDummyContext","result","y","x","setPixel","imgData","r","g","b","a","n","getPixel","BitmapFont","data","text","maxWidth","autoCenter","rows","row","index","rowX","rowY","letterX","c","letterImgData","img","rowText","rowWidth","word","wordWidth","charCode","letterImg","letter","TypedWorkerThreaded","event","BITMAP_FONT_WORKER_REQUEST_TYPE","BitmapFontSystem","request","font","textImageData"],"mappings":"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"}